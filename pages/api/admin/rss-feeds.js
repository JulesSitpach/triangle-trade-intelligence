/**
 * ADMIN API: RSS Feeds Management
 * GET /api/admin/rss-feeds - Returns all RSS feeds with monitoring status
 * POST /api/admin/rss-feeds - Add new RSS feed (for future implementation)
 * PUT /api/admin/rss-feeds/[id] - Update RSS feed settings
 * Provides data for crisis management RSS monitoring
 */

import { createClient } from '@supabase/supabase-js';

// Initialize Supabase client
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

export default async function handler(req, res) {
  if (req.method === 'GET') {
    return handleGetRSSFeeds(req, res);
  } else if (req.method === 'POST') {
    return handleAddRSSFeed(req, res);
  } else if (req.method === 'PUT') {
    return handleUpdateRSSFeed(req, res);
  } else {
    return res.status(405).json({ error: 'Method not allowed' });
  }
}

/**
 * Handle GET request - fetch all RSS feeds with monitoring data
 */
async function handleGetRSSFeeds(req, res) {
  try {
    // TODO: Add admin authentication check
    
    // Get timeframe for activity analysis
    const { timeframe = '30days' } = req.query;
    const daysBack = getDaysFromTimeframe(timeframe);
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - daysBack);

    // Query RSS feeds with recent activity
    const { data: rssFeeds, error: feedsError } = await supabase
      .from('rss_feeds')
      .select(`
        id,
        name,
        url,
        category,
        priority_level,
        is_active,
        check_frequency_minutes,
        last_check_at,
        last_success_at,
        failure_count,
        max_failures_allowed,
        keywords,
        exclusion_keywords,
        created_at,
        updated_at,
        alert_threshold,
        notification_enabled
      `)
      .order('priority_level', { ascending: true });

    if (feedsError && feedsError.code !== 'PGRST116') { // Table doesn't exist
      console.error('Error fetching RSS feeds:', feedsError);
      return res.status(500).json({ error: 'Failed to fetch RSS feeds data' });
    }

    // Query recent RSS activities for feed health
    const { data: recentActivities, error: activitiesError } = await supabase
      .from('rss_feed_activities')
      .select('*')
      .gte('created_at', startDate.toISOString());

    if (activitiesError && activitiesError.code !== 'PGRST116') {
      console.error('Error fetching RSS activities:', activitiesError);
    }

    // Query crisis alerts generated from RSS feeds
    const { data: crisisAlerts, error: alertsError } = await supabase
      .from('crisis_alerts')
      .select('*')
      .eq('source_type', 'rss_feed')
      .gte('created_at', startDate.toISOString());

    if (alertsError && alertsError.code !== 'PGRST116') {
      console.error('Error fetching crisis alerts:', alertsError);
    }

    // If tables don't exist, return empty state
    const feedsData = rssFeeds || [];
    const activitiesData = recentActivities || [];
    const alertsData = crisisAlerts || [];

    // Enrich feed data with activity metrics
    const enrichedFeeds = feedsData.map(feed => {
      // Get activities for this feed
      const feedActivities = activitiesData.filter(activity => 
        activity.feed_id === feed.id
      );

      // Get alerts generated by this feed
      const feedAlerts = alertsData.filter(alert => 
        alert.source_id === feed.id
      );

      // Calculate health metrics
      const healthStatus = calculateFeedHealth(feed, feedActivities);
      const alertsGenerated = feedAlerts.length;

      return {
        ...feed,
        // Health and performance metrics
        health_status: healthStatus.status,
        health_score: healthStatus.score,
        uptime_percentage: healthStatus.uptime,
        avg_response_time: calculateAvgResponseTime(feedActivities),
        
        // Activity metrics
        total_checks: feedActivities.length,
        successful_checks: feedActivities.filter(a => a.status === 'success').length,
        failed_checks: feedActivities.filter(a => a.status === 'error').length,
        alerts_generated: alertsGenerated,
        
        // Recent activity
        last_error: getLastError(feedActivities),
        minutes_since_last_check: getMinutesSince(feed.last_check_at),
        minutes_since_last_success: getMinutesSince(feed.last_success_at),
        
        // Risk indicators
        risk_level: assessFeedRisk(feed, feedActivities),
        needs_attention: healthStatus.needsAttention,
        
        // Format dates
        last_check_formatted: feed.last_check_at ? 
          new Date(feed.last_check_at).toLocaleString() : 'Never',
        last_success_formatted: feed.last_success_at ? 
          new Date(feed.last_success_at).toLocaleString() : 'Never',
        created_at_formatted: new Date(feed.created_at).toLocaleDateString()
      };
    });

    // Calculate summary statistics
    const summary = calculateRSSFeedSummary(enrichedFeeds, activitiesData, alertsData);

    return res.status(200).json({
      rss_feeds: enrichedFeeds,
      summary,
      timeframe,
      date_range: {
        start: startDate.toISOString().split('T')[0],
        end: new Date().toISOString().split('T')[0]
      },
      data_status: {
        total_feeds: enrichedFeeds.length,
        active_feeds: enrichedFeeds.filter(f => f.is_active).length,
        feeds_with_recent_activity: enrichedFeeds.filter(f => f.total_checks > 0).length,
        total_activities_period: activitiesData.length,
        total_alerts_period: alertsData.length
      }
    });

  } catch (error) {
    console.error('RSS feeds API error:', error);
    return res.status(500).json({ 
      error: 'Internal server error',
      message: error.message 
    });
  }
}

/**
 * Handle POST request - add new RSS feed
 */
async function handleAddRSSFeed(req, res) {
  try {
    // TODO: Add admin authentication check
    const {
      name,
      url,
      category,
      priority_level = 'medium',
      check_frequency_minutes = 30,
      keywords = [],
      exclusion_keywords = [],
      alert_threshold = 1,
      notification_enabled = true
    } = req.body;

    // Validate required fields
    if (!name || !url) {
      return res.status(400).json({ 
        error: 'Missing required fields: name, url' 
      });
    }

    // Validate URL format
    try {
      new URL(url);
    } catch {
      return res.status(400).json({ 
        error: 'Invalid URL format' 
      });
    }

    // Insert new RSS feed
    const { data: newFeed, error: insertError } = await supabase
      .from('rss_feeds')
      .insert({
        name,
        url,
        category: category || 'general',
        priority_level,
        is_active: true,
        check_frequency_minutes,
        keywords,
        exclusion_keywords,
        alert_threshold,
        notification_enabled,
        failure_count: 0,
        max_failures_allowed: 3,
        last_check_at: null,
        last_success_at: null
      })
      .select()
      .single();

    if (insertError) {
      console.error('Error inserting RSS feed:', insertError);
      return res.status(500).json({ error: 'Failed to add RSS feed' });
    }

    return res.status(201).json({
      rss_feed: newFeed,
      message: 'RSS feed added successfully'
    });

  } catch (error) {
    console.error('Add RSS feed API error:', error);
    return res.status(500).json({ 
      error: 'Internal server error',
      message: error.message 
    });
  }
}

/**
 * Handle PUT request - update RSS feed
 */
async function handleUpdateRSSFeed(req, res) {
  try {
    // TODO: Add admin authentication check
    const { id } = req.query;
    const updateData = req.body;

    if (!id) {
      return res.status(400).json({ error: 'Feed ID is required' });
    }

    // Update RSS feed
    const { data: updatedFeed, error: updateError } = await supabase
      .from('rss_feeds')
      .update(updateData)
      .eq('id', id)
      .select()
      .single();

    if (updateError) {
      console.error('Error updating RSS feed:', updateError);
      return res.status(500).json({ error: 'Failed to update RSS feed' });
    }

    return res.status(200).json({
      rss_feed: updatedFeed,
      message: 'RSS feed updated successfully'
    });

  } catch (error) {
    console.error('Update RSS feed API error:', error);
    return res.status(500).json({ 
      error: 'Internal server error',
      message: error.message 
    });
  }
}

/**
 * Calculate feed health status
 */
function calculateFeedHealth(feed, activities) {
  const now = new Date();
  
  // Check if feed is overdue
  const minutesSinceLastCheck = getMinutesSince(feed.last_check_at);
  const isOverdue = minutesSinceLastCheck > (feed.check_frequency_minutes * 2);
  
  // Calculate success rate from recent activities
  const recentActivities = activities.slice(-20); // Last 20 checks
  const successRate = recentActivities.length > 0 ? 
    (recentActivities.filter(a => a.status === 'success').length / recentActivities.length) * 100 : 0;
  
  // Calculate uptime percentage
  const uptime = activities.length > 0 ? 
    (activities.filter(a => a.status === 'success').length / activities.length) * 100 : 0;
  
  // Determine health status
  let status = 'healthy';
  let score = 100;
  let needsAttention = false;
  
  if (!feed.is_active) {
    status = 'disabled';
    score = 0;
  } else if (feed.failure_count >= feed.max_failures_allowed) {
    status = 'failed';
    score = 0;
    needsAttention = true;
  } else if (isOverdue) {
    status = 'overdue';
    score = 30;
    needsAttention = true;
  } else if (successRate < 50) {
    status = 'unhealthy';
    score = 40;
    needsAttention = true;
  } else if (successRate < 80) {
    status = 'degraded';
    score = 70;
  }
  
  return {
    status,
    score: Math.round(score),
    uptime: Math.round(uptime * 100) / 100,
    needsAttention
  };
}

/**
 * Calculate average response time from activities
 */
function calculateAvgResponseTime(activities) {
  const activitiesWithResponseTime = activities.filter(a => a.response_time_ms);
  if (activitiesWithResponseTime.length === 0) return 0;
  
  const totalTime = activitiesWithResponseTime.reduce((sum, a) => sum + a.response_time_ms, 0);
  return Math.round(totalTime / activitiesWithResponseTime.length);
}

/**
 * Get last error from activities
 */
function getLastError(activities) {
  const errorActivities = activities
    .filter(a => a.status === 'error')
    .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
  
  return errorActivities.length > 0 ? errorActivities[0].error_message : null;
}

/**
 * Get minutes since a timestamp
 */
function getMinutesSince(timestamp) {
  if (!timestamp) return null;
  return Math.floor((new Date() - new Date(timestamp)) / (1000 * 60));
}

/**
 * Assess feed risk level
 */
function assessFeedRisk(feed, activities) {
  let riskFactors = 0;
  
  if (feed.failure_count > 1) riskFactors++;
  if (feed.failure_count >= feed.max_failures_allowed) riskFactors += 2;
  if (!feed.last_success_at) riskFactors++;
  if (getMinutesSince(feed.last_check_at) > (feed.check_frequency_minutes * 3)) riskFactors++;
  
  const recentFailures = activities.filter(a => 
    a.status === 'error' && 
    (new Date() - new Date(a.created_at)) < (24 * 60 * 60 * 1000) // Last 24 hours
  ).length;
  
  if (recentFailures > 3) riskFactors++;
  
  if (riskFactors <= 1) return 'low';
  if (riskFactors <= 3) return 'medium';
  return 'high';
}

/**
 * Calculate RSS feeds summary statistics
 */
function calculateRSSFeedSummary(feeds, activities, alerts) {
  const total = feeds.length;
  const active = feeds.filter(f => f.is_active).length;
  const healthy = feeds.filter(f => f.health_status === 'healthy').length;
  const needsAttention = feeds.filter(f => f.needs_attention).length;

  // Activity metrics
  const totalChecks = activities.length;
  const successfulChecks = activities.filter(a => a.status === 'success').length;
  const failedChecks = activities.filter(a => a.status === 'error').length;
  const avgResponseTime = activities.length > 0 ? 
    activities.reduce((sum, a) => sum + (a.response_time_ms || 0), 0) / activities.length : 0;

  // Alert metrics
  const totalAlerts = alerts.length;
  const criticalAlerts = alerts.filter(a => a.severity_level === 'critical').length;

  // Category breakdown
  const byCategory = feeds.reduce((acc, feed) => {
    const category = feed.category || 'uncategorized';
    acc[category] = (acc[category] || 0) + 1;
    return acc;
  }, {});

  // Priority breakdown
  const byPriority = feeds.reduce((acc, feed) => {
    acc[feed.priority_level] = (acc[feed.priority_level] || 0) + 1;
    return acc;
  }, {});

  return {
    // Feed counts
    total,
    active,
    inactive: total - active,
    healthy,
    unhealthy: total - healthy,
    needs_attention: needsAttention,
    
    // Health metrics
    overall_health_percentage: total > 0 ? Math.round((healthy / total) * 100) : 0,
    avg_uptime: feeds.length > 0 ? 
      Math.round((feeds.reduce((sum, f) => sum + f.uptime_percentage, 0) / feeds.length) * 100) / 100 : 0,
    
    // Activity metrics
    total_checks: totalChecks,
    successful_checks: successfulChecks,
    failed_checks: failedChecks,
    success_rate: totalChecks > 0 ? Math.round((successfulChecks / totalChecks) * 10000) / 100 : 0,
    avg_response_time: Math.round(avgResponseTime),
    
    // Alert metrics
    total_alerts: totalAlerts,
    critical_alerts: criticalAlerts,
    alerts_per_feed: total > 0 ? Math.round((totalAlerts / total) * 100) / 100 : 0,
    
    // Breakdowns
    by_category: Object.entries(byCategory).map(([category, count]) => ({
      category,
      count,
      percentage: total > 0 ? Math.round((count / total) * 1000) / 10 : 0
    })),
    
    by_priority: Object.entries(byPriority).map(([priority, count]) => ({
      priority_level: priority,
      count,
      percentage: total > 0 ? Math.round((count / total) * 1000) / 10 : 0
    })),
    
    // Risk assessment
    risk_distribution: {
      low: feeds.filter(f => f.risk_level === 'low').length,
      medium: feeds.filter(f => f.risk_level === 'medium').length,
      high: feeds.filter(f => f.risk_level === 'high').length
    },
    
    // Recommendations
    recommendations: generateRSSFeedRecommendations(feeds, activities, alerts)
  };
}

/**
 * Generate RSS feed recommendations
 */
function generateRSSFeedRecommendations(feeds, activities, alerts) {
  const recommendations = [];
  
  const failedFeeds = feeds.filter(f => f.health_status === 'failed').length;
  if (failedFeeds > 0) {
    recommendations.push({
      type: 'critical',
      priority: 'high',
      message: `${failedFeeds} RSS feed(s) have failed and need immediate attention`,
      action: 'Check feed URLs and fix configuration issues'
    });
  }
  
  const overdueFeeds = feeds.filter(f => f.health_status === 'overdue').length;
  if (overdueFeeds > 0) {
    recommendations.push({
      type: 'monitoring',
      priority: 'medium',
      message: `${overdueFeeds} RSS feed(s) are overdue for checking`,
      action: 'Review check frequency settings or system capacity'
    });
  }
  
  const highRiskFeeds = feeds.filter(f => f.risk_level === 'high').length;
  if (highRiskFeeds > 0) {
    recommendations.push({
      type: 'reliability',
      priority: 'medium',
      message: `${highRiskFeeds} RSS feed(s) have high risk levels`,
      action: 'Consider alternative sources or increase monitoring frequency'
    });
  }
  
  const totalChecks = activities.length;
  const successRate = totalChecks > 0 ? 
    (activities.filter(a => a.status === 'success').length / totalChecks) * 100 : 0;
    
  if (successRate < 85) {
    recommendations.push({
      type: 'performance',
      priority: 'medium',
      message: `Overall RSS feed success rate is ${Math.round(successRate)}%, below 85% target`,
      action: 'Review network connectivity and feed reliability'
    });
  }
  
  return recommendations;
}

/**
 * Convert timeframe string to days
 */
function getDaysFromTimeframe(timeframe) {
  switch (timeframe) {
    case '7days': return 7;
    case '30days': return 30;
    case '90days': return 90;
    case '1year': return 365;
    default: return 30;
  }
}